{-# OPTIONS_GHC -Wno-name-shadowing #-}

module Day11
  ( Problem (..),
    Answer (..),
  )
where

import Lib (Answer (..))
import qualified Lib as L (Problem (..))
import Util
import qualified Data.Map.Strict as Map

-- the cache table that shows
type Cache = Map.Map (Int,Int) Int

data Problem = Input String | Problem [Int] deriving (Show)

-- instance Show Problem where
--     show (Input s) = show s
--     show (Problem p) = error "show method for Problem is not defined"

instance L.Problem Problem where
  parse1 = parsePart1
  solve1 = solvePart1
  solve2 = solvePart2

--------------------------------------------------------------------------------

solvePart2 :: Problem -> Answer
solvePart2 (Input input) = solvePart2 $ parsePart1 input
solvePart2 (Problem ns) =
  --map (processNumber 75) ns |> sum |> AnswerInt
  map (\n -> processNumberWithCache n 75 (Map.empty :: Cache)) ns |> map fst |> sum |> AnswerInt

--------------------------------------------------------------------------------
solvePart1 :: Problem -> Answer
solvePart1 (Input input) = solvePart1 $ parsePart1 input
solvePart1 (Problem ns) =
  map (`processNumber` 25) ns |> sum |> AnswerInt
  --iterate processNumbers ns !! 25 |> length |> AnswerInt


-- given number and depth return count of numbers that were generated by processing
processNumberWithCache :: Int -> Int -> Cache -> (Int, Cache)
processNumberWithCache _ 0 cache = (1, cache)
processNumberWithCache 0 depth cache = processNumberWithCache 1 (depth-1) cache
processNumberWithCache number depth cache =
  case Map.lookup (number,depth) cache of
    Nothing ->
      if odd len_n then (odd_result, new_odd_cache)
      else (even_result, new_even_cache)
      where
        len_n = digitCount number
        (odd_result, odd_cache) = processNumberWithCache (2024*number) (depth-1) cache
        new_odd_cache = Map.insert (number,depth) odd_result odd_cache
        (n1,n2) = splitNumber number
        (result1,cache1) = processNumberWithCache n1 (depth-1) cache
        (result2,cache2) = processNumberWithCache n2 (depth-1) cache1
        even_result = result1+result2
        new_even_cache = Map.insert (number, depth) even_result cache2
    Just v  -> (v, cache)

processNumber :: Int -> Int -> Int
processNumber _ 0 = 1
processNumber 0 depth = processNumber 1 (depth - 1)
processNumber number depth =
  if odd len_n then processNumber (2024 * number) d_1
  else processNumber n1 d_1 + processNumber n2 d_1
  where
    len_n = digitCount number
    d_1 = depth - 1
    (n1,n2) = splitNumber number

-- processNumbers :: [Int] -> [Int]
-- processNumbers [] = []
-- processNumbers (0 : ns) = 1 : processNumbers ns
-- processNumbers (n : ns) =
--   let len_n = digitCount n
--    in if odd len_n
--         then 2024 * n : processNumbers ns
--         else splitNumber n |> (\(n1, n2) -> n1 : n2 : processNumbers ns)

splitNumber :: Int -> (Int, Int)
splitNumber n =
  let mid = digitCount n `div` 2
   in show n |> splitAt mid |> (\(n1, n2) -> (read n1 :: Int, read n2 :: Int))

--------------------------------------------------------------------------------

parsePart1 :: String -> Problem
parsePart1 input =
  [read word :: Int | word <- words input] |> Problem